Implementation steps : forward approach or top ---down approach
1. create Java  project.(Same J2EE workspace , change perspective to core java)

2. Add external jars.(hibernate 5 jars + JDBC driver jar)
(in a user library)



3. Create hibernate.cfg.xml(copy from help folder & make necessary changes)  : location  : run-time classpath(Create <resources> (source folder)-- from IDE & store hibernate.cfg.xml) 

4.  Hibernate configuration steps (bootstrapping sequence) for creating  singleton instance of the Hibernate  SF -- in HibernateUtils class.(using static init block) 
Copy <utils> provided in help under <src>

Detailed Explanation
Steps 
1. StandardServiceRegistry reg = new StandardServiceRegistryBuilder().configure().build();

2. SessionFactory sf=new MetadataSources(reg).buildMetadata().buildSessionFactory();


5. Identify persistence requirements & wrap it in POJO class
Features of Hib. based POJO/JPA based Entity

5.1 : public , pkged class, may implement Serializable(not mandatory from hibernate specifications)
5.2 Must provide def. constr.(mandatory)
5.3 can supply optionally paramed constr.
5.4 declare private D.M , non-static ,non-transient---properties of POJO
generate getters & setters. 
5.5 One property -- must be unique ID for POJO. --- Data type of property MUST be Serializable



6.Describe the mapping(ORM) to the Hibernate frmwork
Either Generate the POJO.hbm.xml :  OR use hibernate annotations to avoid writing HBM document

eg : BookPOJO

<mapping class="F.Q POJO cls name/>
OR
xml (pojo.hbm.xml)
<mapping resource="pojo.hbm.xml"/>


Annotation support from pkg : javax.persistence (JPA)
Help for annotations :

1. Mark the entity or POJO class with @Entity annotation
@Entity : class level ---mandatory

2. @Table(name="table name") : class level annotation ---optional

3. @Id : can be field level OR getter  method level. ---mandatory
4. optional

@GeneratedValue(strategy=GenerationType.AUTO) --> id generator supplied by persistence  provider(app srvr's or ORM frmwork i.e hibernate) & not by DB
Mandatory Rule for Identifier property type---must be Serializable

5. @Column(name="col name ") --> not mandatory if same names

@Column(columnDefinition= "double(10,2)")
private double price;


3,4,5 : applicable to Entity id property
6.@Column(name="upper-cased  col name") : for rest of prop to col names mapping(optional)	
eg : for additional @Column annotations (method level annotation)
@Entity
public class Flight implements Serializable {

@Column(updatable = false, name = "flight_name", nullable = false, length=50)
public String getName() { ... }

6.IMPORTANT --- Add POJO (mapping) entry in hibernate.cfg.xml


NOTE : Annotations like -- @Id,@GeneratedValue,@Column,@ElementCollection,@Temporal
--can either be applied @ field level(before data member) or property level(before getter)

@Temporal --- can be applied to --java.util.Date,Calendar, GregorianCalendar


7. Create Hibernate based DAO Layer.
DAO Layer --- No constructor or clean up required. 

Directly Create CRUD style methods

Create Hib sesion.(using openSession initially) -- typically just before CRUD.(from DAO layer)

7.1  beginTx -- transaction just represents a piece of work.
7.2 Perform CRUD operations using mainly Session API(eg : save/persist/delete/update/HQL)
7.3 if no errs : commit Tx & close the session.--in case of errs , rollback the tx. & close Hib session.


Objective 1 - Simplest --- Test hib frmwork -- using create part of 
1. CRUD logic (save method)
API (method) of org.hibernate.Session
public Serializable save(Object o) throws HibernateException

I/P  ---transient POJO ref.
save() method auto persists transient POJO on the DB(upon committing tx) & returns unique serializable ID generated by  hib frmwork.

NOTE :If  entity type has a generated identifier, the value is associated to the instance when the save or persist is called. If the identifier is not automatically generated, the application-assigned (usually natural) key value has to be set on the instance before save or persist is called.


2. Hibernate session API -- for data retrieval
API (method) of org.hibernate.Session
public <T> get(Class<T> c,Serializable id) throws HibernateException
T -- type of POJO
Returns --- null -- if id is not found.
returns PERSISTENT pojo ref if id is found.

Usage of Hibernate Session API's get()
int id=101;
BookPOJO b1=hibSession.get(BookPOJO.class,id);

BookPOJO b1=(BookPOJO)hibSession.get(Class.forName("pojos.BookPOJO"),id);

2. Display all books info : 

using HQL -- Hibernate Query Language --- Objectified version of SQL --- where table names will be replaced by POJO class names & table col names will replaced by POJO property names.
(JPA--- Java Persistence API  compliant syntax --- JPQL ) 
eg --- HQL --- "from BookPOJO"
eg JPQL -- "select b from BookPOJO b"

2.1 Create Query Object --- from Session i/f
org.hibernate.query.Query<T>--- i/f

<T> Query<T> createQuery(String queryString,
                         Class<T> resultType)

eg : Query<Book> q=hs.createQuery(hql/jpql,Book.class);

2.2. Execute query to get List of selected PERSISTENT POJOs
API of org.hibernate.query.Query i/f
(Taken from javax.persistence.TypedQuery<T>)

List<T> getResultList()

Execute a SELECT query and return the query results as a generic List<T>.
T -- type of POJO / Result

eg : hs,tx
String jpql="select b from Book b";
try {
    List<Book> l1=hs.createQuery(jpql,Book.class).getResultList();
}

 Usage ---
String hql="select b from BookPOJO b";
List<BookPOJO> l1=hibSession.createQuery(hql).getResultList();


3. Passing IN params to query. & execute it.
Objective : Display all books from specified author , with price < specified price.
API from org.hibernate.query.Query i/f

Query<R> setParameter(String name,Object value)

Bind a named query parameter using its inferred Type. 
name -- query param name
value -- param value.I

String hql="select b from BookPOJO b where b.price < :sp_price and b.author = :sp_auth";

How to set IN params ?
org.hibernate.query.Query<T> API
public Query<T> setPrameter(String pName,Object val)

List<Book> l1 = hibSession.createQuery(hql,Book.class).setParameter("sp_price",user_price).setParameter("sp_auth",user_auth).getResultList();


Objective --Offer discount on all old books
i/p -- date , disc amt

4. Updating POJOs --- Can be done either with select followed by update or ONLY with update queries(following is eg of 2nd option)
Objective : dec. price of all books with author=specified author.
 

String hql = "update BookPOJO b set b.price = b.price - :disc where b.author = :au and b.publishDate < :dt ";

set named In params 
exec it (executeUpdate) ---	

int updateCount= hs.createQuery(hql).setParameter("disc", disc).setParameter("dt", d1).executeUpdate();

---This approach is typically NOT recommended often, since it bypasses L1 cache . Cascading is not supported. Doesn't support optismistic locking directly.
						

5. Delete operations.
API of org.hibernate.Session
--void delete(Object object)  throws HibernateException 
---POJO is marked for removal , corresponding row from DB will be deleted after comitting tx & closing of session.

OR 
5.5 
One can use directly "delete HQL" & perform deletions.
eg 
int deletedRows = hibSession.createQuery ("DELETE Subscription s  WHERE s.subscriptionDate < :today").setParameter ("today", new Date ()).executeUpdate ();

API of org.hibernate.query.Query<T>


1. Iterator iterate() throws HibernateException

Return the query results as an Iterator. If the query contains multiple results per row, the results are returned  Object[].

Entities returned --- in lazy manner

Pagination 

2. Query setMaxResults(int maxResults)

    Set the maximum number of rows to retrieve. If not set, there is no limit to the number of rows retrieved.

3.  Query setFirstResult(int firstResult)

    Set the first row to retrieve. If not set, rows will be retrieved beginnning from row 0. (NOTE row num starts from 0)

eg --- List<CustomerPOJO> l1=sess.createQuery("select c from CustomerPOJO c").setFirstResult(30).setMaxResults(10).list();


4.How to count rows & use it in pagination techniques?
	 int pageSize = 10;
    String countQ = "Select count (f.id) from Foo f";
    Query countQuery = session.createQuery(countQ);
    Long countResults = (Long) countQuery.uniqueResult();
    int lastPageNumber = (int) ((countResults / pageSize) + 1);
 
    Query selectQuery = session.createQuery("From Foo");
    selectQuery.setFirstResult((lastPageNumber - 1) * pageSize);
    selectQuery.setMaxResults(pageSize);
    List<Foo> lastPage = selectQuery.list();


5.  org.hibernate.query.Qyery API

<T> getSingleResult()

Executes a SELECT query that returns a single typed result.

Returns: Returns a single instance(persistent) that matches the query.
    
Throws:
    NoResultException - if there is no result
    NonUniqueResultException - if more than one result
    IllegalStateException - if called for a Java Persistence query language UPDATE or DELETE statement




6. How to get Scrollable Result from Query?

ScrollableResults scroll(ScrollMode scrollMode) throws HibernateException

Return the query results as ScrollableResults. The scrollability of the returned results depends upon JDBC driver support for scrollable ResultSets.

Then can use methods of ScrollableResults ---first,next,last,scroll(n) .

7. How to create Named query from Session i/f?
What is a named query ?
Its a technique to group the HQL statements in single location(typically in POJOS)  and lately refer them by some name whenever need to use them. It helps largely in code cleanup because these HQL statements are no longer scattered in whole code.

Fail fast: Their syntax is checked when the session factory is created, making the application fail fast in case of an error.
Reusable: They can be accessed and used from several places which increase re-usability.


eg : In POJO class, at class level , one can declare Named Queries
@Entity
@NamedQueries
({@NamedQuery(name=DepartmentEntity.GET_DEPARTMENT_BY_ID, query="select d from DepartmentEntity d where d.id = :id")}
public class Department{....}

Usgae 
Department d1 = (Department) session.getNamedQuery(DepartmentEntity.GET_DEPARTMENT_BY_ID).setInteger("id", 1);

8. How to invoke native sql from hibernate?
Query q=hs.createSQLQuery("select * from books").addEntity(BookPOJO.class);
 l1 = q.list();


9. Hibernate Criteria API
A powerful and elegent alternative to HQL 
Well adapted for dynamic search functionalities where complex Hibernate queries have to be generated 'on-the-fly'.

Typical steps are -- Create a criteria for POJO, add restrictions , projections ,add order & then fire query(via list() or uniqueResult())

10. For composite primary key
Rules on prim key class 
Annotation -- @Embeddable (& NOT @Entity)
Must be Serializable.
Must implement hashCode & equals as per general contract.

In Owning Entity class
Add usual annotation -- @Id.



-----------------------------

Annotations related to relationships(associations) between entities
0. one -----> one : unidirectional relationship.
In Customer Entity class ---

@OneToOne(cascade=CascadeType.ALL)
@JoinColumn(name="addr_id")  
private Address adr;
---owning side

In Address Entity --- no need of additional annotations.




1. one 1 <----> one : bidirectional relationship.
@OneToOne(cascade=CascadeType.ALL,mappedBy="cust")  
private Address adr;
---owning side

@OneToOne
@JoinColumn(name="cust_id")
private Customer cust;

2. one 1 <---->* many : bi-directional
At one side : field level annotaion @OneToMany(cascade=CascadeType.ALL,mappedBy="propertyName in many side")
NOTE -- cascade is optional attribute. can be skipped .

At many side :
@ManyToOne
@JoinColumn(name="prim key column name of one side")

Meaning - Acts as Foreign key column referred from one side

eg -- Course 1----* Students
Table structure for understanding --- 
Course table --- course_id(PK),name,start_date,end_date,fees

Students table ---
id(PK),name,addr,course_id(FK)


@Id
@GeneratedValue(strategy=GenerationType.AUTO)
private int courseId;
.....
@OneToMany(cascade=CascadeType.ALL,mappedBy="myCourse")
private List<Student> students;

In Student POJO
@ManyToOne
@JoinColumn(name="courseId")
private Course myCourse;
	
	
eg One User having multiple Vehicles.
In User class

@OneToMany(mappedBy="user")
private Collection<Vehicle> vehicles=new ArrayList<>();

 ---mappedBy attribute tells hibernate that instead of having a separate join table --map vehicles by user i.e user = name of the property appearing in Vehicle class , anno by @ManyToOne



In Vehicle class -- to supply our own name for the join col (o.w it will take def name)
@ManyToOne
@JoinColumn(name="USER_ID")
private User user;

	




Annotation for Date
@Temporal(TemporalType.DATE)
private Date startDate;
Creates date type of column in underlying DB(java.util.Date or java.util.Calendar or GC)
	

Annotation for Time
@Temporal(TemporalType.TIME)
private Date openingTime;
Creates time type of column in underlying DB

Annotation for TimeStamp
@Temporal(TemporalType.TIMESTAMP)
private Date closingDateTime;
Creates datetime type of column in underlying DB


More details on one ---many
The association may be bidirectional. In a bidirectional relationship, only one of the sides has to be the owner: ---  the owner is responsible for the association column(s) update.

To declare a side as not responsible for the relationship, the attribute mappedBy is used. mappedBy refers to the property name of the association on the owner side.  You MUST NOT declare the join column since it has already been declared on the owners side.



Some more annotations
@Entity
@Table(name = "stock", catalog = "scott", uniqueConstraints = {
@UniqueConstraint(columnNames = "STOCK_NAME"),
@UniqueConstraint(columnNames = "STOCK_CODE") })


For Identity generator
	@GeneratedValue(strategy=GenerationType.IDENTITY)
	@Column(name="b_id")
	private int bookId;



------------------------
Steps for oracle
1.
create a sequence using PL-SQL ----
CREATE SEQUENCE my_seq
    MINVALUE 1
    START WITH 1
    INCREMENT BY 1
    CACHE 20;
2.In BookPOJO

@SequenceGenerator(name="seq_gen",sequenceName="my_seq",allocationSize=1)
	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCEgenerator="seq_gen")
	@Column(name="book_id")
	private int bookId;

3. If book_id say has reached 30, & then u drop table & generate next row , it shows 31.
If u want to reset it to 1 ---drop sequence my_seq
& then it starts with id vals 1.....
--------------------
LOB handling annotations
@Lob
private byte[] data;


To restart hibernate sequence
1. DROP SEQUENCE hibernate_sequence;

2. CREATE SEQUENCE hibernate_sequence START WITH 1;
-------------------------

For HAS-A relationship eg : Student HAS - A address.





